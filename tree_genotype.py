
# tree_genotype.py

import random
from copy import deepcopy
from fitness import manhattan

class TreeGenotype():
    def __init__(self):
        self.fitness = None
        self.genes = None


    @classmethod
    def initialization(cls, mu, depth_limit, **kwargs):
        population = [cls() for _ in range(mu)]

        # 2a TODO: Initialize genes member variables of individuals
        #          in population using ramped half-and-half.
        #          Pass **kwargs to your functions to give them
        #          the sets of terminal and nonterminal primitives.

        return population


    def serialize(self):
        # 2a TODO: Return a string representing self.genes in the required format.
        return 'Unimplemented'


    def deserialize(self, serialization):
        # 2a TODO: Complete the below code to recreate self.genes from serialization,
        #          which is a string generated by your serialize method.
        #          We have provided logic for tree traversal to help you get started,
        #          but you need to flesh out this function and make the genes yourself.

        lines = serialization.split('\n')

        # TODO: Create the root node yourself here based on lines[0]
        root = None

        parent_stack = [(root, 0)]
        for line in lines[1:]:
            if not line:
                continue
            my_depth = line.count('|')
            my_primitive = line.strip('|')
            parent, parent_depth = parent_stack.pop()
            right_child = False
            while parent_stack and parent_depth >= my_depth:
                parent, parent_depth = parent_stack.pop()
                right_child = True

            # TODO: Create a node using the above variables as appropriate.
            node = None

            parent_stack.extend([(parent, parent_depth), \
                                 (node, my_depth)])

        # TODO: Use the data structure you've created to assign self.genes.
        self.genes = None


    def recombine(self, mate, depth_limit, **kwargs):
        child = self.__class__()

        # 2b TODO: Recombine genes of mate and genes of self to
        #          populate child's genes member variable.
        #          We recommend using deepcopy, but also recommend
        #          that you deepcopy the minimal amount possible.

        return child


    def mutate(self, depth_limit, **kwargs):
        mutant = self.__class__()
        mutant.genes = deepcopy(self.genes)

        # 2b TODO: Mutate mutant.genes to produce a modified tree.

        return mutant

